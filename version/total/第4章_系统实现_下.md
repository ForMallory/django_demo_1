# 第4章 系统的实现（下）

## 4.4 算法模块

### 4.4.1 协同过滤算法实现

协同过滤算法是本系统推荐功能的核心，采用基于用户和基于商品的混合推荐策略。

**推荐系统类（recommender.py）：**

```python
import numpy as np
from collections import defaultdict
from django.db.models import Count, Q
from .models import UserBehavior, Product, User, OrderItem
from django.utils import timezone

class RecommenderSystem:
    """推荐系统类"""
    
    def __init__(self, alpha=0.5):
        """
        初始化推荐系统
        :param alpha: 用户协同过滤和商品协同过滤的权重
        """
        self.alpha = alpha
        self.user_item_matrix = None
        self.item_user_matrix = None
        self.users = []
        self.products = []
```

### 4.4.2 评分矩阵构建

**构建用户-商品评分矩阵：**

```python
def build_matrices(self):
    """构建用户-商品评分矩阵"""
    # 获取所有用户和商品
    self.users = list(User.objects.filter(
        is_superuser=False
    ).values_list('id', flat=True))
    self.products = list(Product.objects.values_list('id', flat=True))
    
    if not self.users or not self.products:
        return
    
    # 创建用户和商品的索引映射
    user_idx = {user_id: idx for idx, user_id in enumerate(self.users)}
    product_idx = {product_id: idx for idx, product_id in enumerate(self.products)}
    
    # 初始化矩阵
    n_users = len(self.users)
    n_products = len(self.products)
    self.user_item_matrix = np.zeros((n_users, n_products))
    
    # 填充评分矩阵
    behaviors = UserBehavior.objects.all()
    for behavior in behaviors:
        if behavior.user_id in user_idx and behavior.product_id in product_idx:
            u_idx = user_idx[behavior.user_id]
            p_idx = product_idx[behavior.product_id]
            self.user_item_matrix[u_idx, p_idx] += behavior.get_score()
    
    # 转置得到商品-用户矩阵
    self.item_user_matrix = self.user_item_matrix.T
    
    return user_idx, product_idx
```

**实现要点：**

1. **数据获取**：从数据库获取所有用户和商品
2. **索引映射**：建立ID到矩阵索引的映射关系
3. **矩阵初始化**：创建零矩阵
4. **评分填充**：根据用户行为填充评分（浏览=1，加购=3，购买=5）
5. **矩阵转置**：生成商品-用户矩阵用于商品协同过滤

### 4.4.3 相似度计算

**余弦相似度计算：**

```python
def cosine_similarity(self, matrix):
    """
    计算余弦相似度
    :param matrix: 输入矩阵
    :return: 相似度矩阵
    """
    # 计算每行的范数
    norms = np.linalg.norm(matrix, axis=1, keepdims=True)
    norms[norms == 0] = 1  # 避免除零
    
    # 归一化
    normalized_matrix = matrix / norms
    
    # 计算余弦相似度
    similarity = np.dot(normalized_matrix, normalized_matrix.T)
    
    return similarity
```

**数学原理：**

余弦相似度公式：
```
sim(A, B) = cos(θ) = (A · B) / (||A|| × ||B||)
```

其中：
- A · B 表示向量点积
- ||A|| 表示向量A的范数（长度）
- θ 表示两个向量之间的夹角

### 4.4.4 基于用户的协同过滤

```python
def user_based_cf(self, user_id, user_idx, product_idx, top_n=10):
    """
    基于用户的协同过滤
    :param user_id: 目标用户ID
    :param user_idx: 用户索引映射
    :param product_idx: 商品索引映射
    :param top_n: 返回top N个推荐
    :return: 推荐商品ID列表及评分
    """
    if user_id not in user_idx:
        return []
    
    u_idx = user_idx[user_id]
    
    # 计算用户相似度
    user_similarity = self.cosine_similarity(self.user_item_matrix)
    
    # 获取目标用户的相似用户（排除自己）
    similarities = user_similarity[u_idx].copy()
    similarities[u_idx] = 0  # 排除自己
    
    # 预测评分
    predictions = np.dot(similarities, self.user_item_matrix)
    
    # 排除用户已经交互过的商品
    user_interacted = self.user_item_matrix[u_idx] > 0
    predictions[user_interacted] = -1
    
    return predictions
```

**算法步骤：**

1. 计算目标用户与所有其他用户的相似度
2. 找到最相似的K个用户
3. 根据相似用户的评分预测目标用户对商品的评分
4. 排除用户已经交互过的商品
5. 返回评分最高的商品

### 4.4.5 基于商品的协同过滤

```python
def item_based_cf(self, user_id, user_idx, product_idx, top_n=10):
    """
    基于商品的协同过滤
    :param user_id: 目标用户ID
    :param user_idx: 用户索引映射
    :param product_idx: 商品索引映射
    :param top_n: 返回top N个推荐
    :return: 推荐商品ID列表及评分
    """
    if user_id not in user_idx:
        return []
    
    u_idx = user_idx[user_id]
    
    # 计算商品相似度
    item_similarity = self.cosine_similarity(self.item_user_matrix)
    
    # 获取用户评分
    user_ratings = self.user_item_matrix[u_idx]
    
    # 预测评分
    predictions = np.dot(user_ratings, item_similarity)
    
    # 排除用户已经交互过的商品
    user_interacted = self.user_item_matrix[u_idx] > 0
    predictions[user_interacted] = -1
    
    return predictions
```

**算法步骤：**

1. 计算商品之间的相似度
2. 获取用户的历史评分
3. 根据用户喜欢的商品和商品相似度预测评分
4. 排除用户已经交互过的商品
5. 返回评分最高的商品

### 4.4.6 评分归一化

```python
def normalize_scores(self, scores):
    """
    归一化评分到0-1之间
    :param scores: 原始评分
    :return: 归一化后的评分
    """
    if len(scores) == 0:
        return scores
    
    min_score = np.min(scores)
    max_score = np.max(scores)
    
    if max_score == min_score:
        return np.ones_like(scores) * 0.5
    
    return (scores - min_score) / (max_score - min_score)
```

**归一化公式：**

```
normalized_score = (score - min) / (max - min)
```

归一化的作用：
- 将不同范围的评分统一到[0,1]区间
- 便于不同算法结果的融合
- 提高推荐结果的稳定性

### 4.4.7 生命周期推荐

```python
def get_lifecycle_recommendations(self, user):
    """
    获取基于生命周期的推荐
    :param user: 用户对象
    :return: 需要补充的商品ID列表
    """
    if not user.family:
        return []
    
    # 获取家庭的所有订单项
    order_items = OrderItem.objects.filter(
        order__family=user.family,
        order__status__in=['paid', 'shipped', 'completed']
    ).select_related('product')
    
    lifecycle_products = []
    for item in order_items:
        if item.should_recommend():
            lifecycle_products.append(item.product.id)
    
    return lifecycle_products
```

**生命周期判断（models.py）：**

```python
def should_recommend(self):
    """判断是否应该推荐（生命周期剩余30%）"""
    if not self.product.lifecycle:
        return False
    days_passed = (timezone.now() - self.purchase_date).days
    lifecycle_percentage = days_passed / self.product.lifecycle
    return lifecycle_percentage >= 0.7
```

**实现逻辑：**

1. 获取家庭的所有已支付订单
2. 计算每个商品的使用时间
3. 判断是否达到生命周期的70%
4. 返回需要补货的商品列表

### 4.4.8 混合推荐策略

```python
def get_recommendations(self, user, top_n=10):
    """
    获取综合推荐结果
    :param user: 用户对象
    :param top_n: 返回top N个推荐
    :return: 推荐商品列表
    """
    # 构建矩阵
    result = self.build_matrices()
    if result is None:
        return []
    
    user_idx, product_idx = result
    
    # 获取生命周期推荐
    lifecycle_products = self.get_lifecycle_recommendations(user)
    
    # 如果用户不在索引中，返回热门商品
    if user.id not in user_idx:
        popular_products = Product.objects.annotate(
            behavior_count=Count('behaviors')
        ).order_by('-behavior_count')[:top_n]
        return list(popular_products)
    
    # 基于用户的协同过滤
    user_based_scores = self.user_based_cf(user.id, user_idx, product_idx)
    
    # 基于商品的协同过滤
    item_based_scores = self.item_based_cf(user.id, user_idx, product_idx)
    
    # 加权融合
    if len(user_based_scores) > 0 and len(item_based_scores) > 0:
        # 归一化
        user_based_scores = self.normalize_scores(user_based_scores)
        item_based_scores = self.normalize_scores(item_based_scores)
        
        # 加权
        final_scores = (self.alpha * user_based_scores + 
                       (1 - self.alpha) * item_based_scores)
    else:
        final_scores = (user_based_scores if len(user_based_scores) > 0 
                       else item_based_scores)
    
    # 提升生命周期商品的评分
    product_idx_reverse = {idx: product_id 
                          for product_id, idx in product_idx.items()}
    for idx, product_id in product_idx_reverse.items():
        if product_id in lifecycle_products:
            final_scores[idx] += 2.0  # 大幅提升评分
    
    # 获取top N推荐
    top_indices = np.argsort(final_scores)[::-1][:top_n]
    
    # 转换为商品ID
    recommended_product_ids = [product_idx_reverse[idx] 
                              for idx in top_indices 
                              if final_scores[idx] > 0]
    
    # 获取商品对象
    recommended_products = Product.objects.filter(
        id__in=recommended_product_ids
    )
    
    # 按推荐顺序排序
    product_dict = {p.id: p for p in recommended_products}
    ordered_products = [product_dict[pid] 
                       for pid in recommended_product_ids 
                       if pid in product_dict]
    
    return ordered_products
```

**混合策略说明：**

1. **双算法融合**：结合用户协同过滤和商品协同过滤
2. **权重平衡**：使用α=0.5实现两种算法的平衡
3. **生命周期增强**：对需要补货的商品大幅提升评分
4. **冷启动处理**：新用户返回热门商品
5. **结果排序**：按最终评分排序并返回Top N

## 4.5 购物车与订单模块

### 4.5.1 添加商品到购物车

```python
@login_required
def add_to_cart(request, product_id):
    """添加商品到购物车"""
    if not request.user.family:
        messages.error(request, '您还没有加入家庭')
        return redirect('products')
    
    product = get_object_or_404(Product, id=product_id)
    cart, _ = Cart.objects.get_or_create(family=request.user.family)
    
    # 检查库存
    if product.stock <= 0:
        messages.error(request, '商品库存不足')
        return redirect('products')
    
    # 添加或更新购物车项
    cart_item, created = CartItem.objects.get_or_create(
        cart=cart,
        product=product,
        defaults={'quantity': 1}
    )
    
    if not created:
        cart_item.quantity += 1
        cart_item.save()
    
    # 记录行为
    UserBehavior.objects.create(
        user=request.user,
        product=product,
        behavior_type='add_to_cart'
    )
    
    messages.success(request, f'{product.name} 已添加到购物车')
    return redirect(request.META.get('HTTP_REFERER', 'products'))
```

**实现要点：**

1. **权限检查**：确保用户属于某个家庭
2. **库存验证**：检查商品库存是否充足
3. **购物车获取**：获取或创建家庭购物车
4. **商品添加**：使用`get_or_create`实现添加或更新
5. **行为记录**：记录加购行为用于推荐算法
6. **用户反馈**：使用消息框架提供操作反馈

### 4.5.2 购物车展示

```python
@login_required
def cart_view(request):
    """购物车页面"""
    if not request.user.family:
        messages.error(request, '您还没有加入家庭')
        return redirect('home')
    
    cart, _ = Cart.objects.get_or_create(family=request.user.family)
    cart_items = cart.items.all().select_related('product')
    
    context = {
        'cart': cart,
        'cart_items': cart_items,
        'cart_count': cart.get_items_count(),
    }
    
    return render(request, 'cart.html', context)
```

**购物车模型方法：**

```python
class Cart(models.Model):
    """购物车模型"""
    
    def get_total_price(self):
        """计算购物车总价"""
        return sum(item.get_total_price() for item in self.items.all())
    
    def get_items_count(self):
        """获取购物车商品数量"""
        return sum(item.quantity for item in self.items.all())
```

### 4.5.3 修改购物车商品数量

```python
@login_required
def update_cart_item(request, item_id):
    """更新购物车项数量"""
    if request.method == 'POST':
        cart_item = get_object_or_404(CartItem, id=item_id)
        
        # 检查权限
        if cart_item.cart.family != request.user.family:
            return JsonResponse({'success': False, 'error': '无权限'})
        
        quantity = int(request.POST.get('quantity', 1))
        
        if quantity <= 0:
            cart_item.delete()
        else:
            # 检查库存
            if quantity > cart_item.product.stock:
                return JsonResponse({'success': False, 'error': '库存不足'})
            
            cart_item.quantity = quantity
            cart_item.save()
        
        return JsonResponse({'success': True})
    
    return JsonResponse({'success': False})
```

### 4.5.4 订单结算

```python
@login_required
@transaction.atomic
def checkout(request):
    """结算"""
    if not request.user.family:
        messages.error(request, '您还没有加入家庭')
        return redirect('home')
    
    cart = get_object_or_404(Cart, family=request.user.family)
    cart_items = cart.items.all().select_related('product')
    
    if not cart_items:
        messages.error(request, '购物车为空')
        return redirect('cart')
    
    # 检查库存
    for item in cart_items:
        if item.quantity > item.product.stock:
            messages.error(request, f'{item.product.name} 库存不足')
            return redirect('cart')
    
    # 创建订单
    total_price = cart.get_total_price()
    order = Order.objects.create(
        family=request.user.family,
        user=request.user,
        total_price=total_price,
        status='paid'
    )
    
    # 创建订单项并更新库存
    for item in cart_items:
        OrderItem.objects.create(
            order=order,
            product=item.product,
            quantity=item.quantity,
            price=item.product.price
        )
        
        # 更新库存
        item.product.stock -= item.quantity
        item.product.save()
        
        # 记录购买行为
        UserBehavior.objects.create(
            user=request.user,
            product=item.product,
            behavior_type='purchase'
        )
    
    # 清空购物车
    cart_items.delete()
    
    messages.success(request, f'订单创建成功！订单号：{order.id}')
    return redirect('order_detail', order_id=order.id)
```

**实现要点：**

1. **事务处理**：使用`@transaction.atomic`确保数据一致性
2. **库存检查**：在创建订单前验证所有商品库存
3. **订单创建**：创建订单和订单项记录
4. **库存扣减**：更新商品库存
5. **行为记录**：记录购买行为
6. **购物车清空**：删除购物车中的所有商品
7. **跳转详情**：跳转到订单详情页面

## 4.6 商品模块

### 4.6.1 商品列表展示

```python
@login_required
def products(request):
    """商品浏览页面"""
    # 获取所有分类
    categories = Category.objects.all()
    
    # 获取筛选参数
    category_id = request.GET.get('category')
    search_query = request.GET.get('search', '')
    
    # 构建查询
    products_list = Product.objects.all()
    
    if category_id:
        products_list = products_list.filter(category_id=category_id)
    
    if search_query:
        products_list = products_list.filter(
            Q(name__icontains=search_query) | 
            Q(description__icontains=search_query)
        )
    
    products_list = products_list.order_by('-created_at')
    
    # 获取购物车数量
    cart_count = 0
    if request.user.family:
        cart = Cart.objects.filter(family=request.user.family).first()
        if cart:
            cart_count = cart.get_items_count()
    
    context = {
        'products': products_list,
        'categories': categories,
        'selected_category': category_id,
        'search_query': search_query,
        'cart_count': cart_count,
    }
    
    return render(request, 'products.html', context)
```

**实现要点：**

1. **分类筛选**：支持按商品分类筛选
2. **搜索功能**：支持按商品名称和描述搜索
3. **查询优化**：使用Q对象实现多字段搜索
4. **排序**：按创建时间倒序排列
5. **购物车统计**：显示购物车商品数量

### 4.6.2 商品详情展示

```python
@login_required
def product_detail(request, product_id):
    """商品详情"""
    product = get_object_or_404(Product, id=product_id)
    
    # 记录浏览行为
    UserBehavior.objects.create(
        user=request.user,
        product=product,
        behavior_type='view'
    )
    
    # 获取相似商品（同分类）
    similar_products = Product.objects.filter(
        category=product.category
    ).exclude(id=product.id)[:4]
    
    # 获取购物车数量
    cart_count = 0
    if request.user.family:
        cart = Cart.objects.filter(family=request.user.family).first()
        if cart:
            cart_count = cart.get_items_count()
    
    context = {
        'product': product,
        'similar_products': similar_products,
        'cart_count': cart_count,
    }
    
    return render(request, 'product_detail.html', context)
```

**实现要点：**

1. **行为记录**：自动记录浏览行为
2. **相似推荐**：展示同分类的其他商品
3. **详情展示**：显示商品完整信息
4. **操作按钮**：提供加入购物车等操作

### 4.6.3 商品搜索功能

**搜索实现：**

```python
# 使用Q对象实现多字段搜索
from django.db.models import Q

products = Product.objects.filter(
    Q(name__icontains=search_query) | 
    Q(description__icontains=search_query)
)
```

**搜索模板：**

```html
<form method="get" class="search-bar">
    <input type="text" name="search" class="search-input" 
           placeholder="搜索商品..." value="{{ search_query }}">
    <button type="submit" class="btn btn-primary">搜索</button>
</form>
```

本章下半部分详细介绍了推荐算法模块、购物车与订单模块、商品模块的实现，包括核心算法代码、业务逻辑处理和关键功能实现。至此，系统的所有主要功能模块实现完毕。

